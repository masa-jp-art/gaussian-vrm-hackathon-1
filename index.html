<!DOCTYPE html>
<head>
  <title>Simple GVRM Viewer — Fluid Void</title>
  <style>
    html, body { margin: 0; height: 100%; overflow: hidden; background: #000; }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.min.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/",
        "@pixiv/three-vrm": "https://cdn.jsdelivr.net/npm/@pixiv/three-vrm@2.1.0/lib/three-vrm.module.js",
        "gaussian-splats-3d": "https://naruya.github.io/gs-edit/lib/gaussian-splats-3d.module.js",
        "jszip": "https://cdn.jsdelivr.net/npm/jszip@3.10.1/+esm",
        "gvrm": "https://naruya.github.io/gs-edit/lib/gaussian-vrm.min.js"
      }
    }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GVRM } from 'gvrm';

    // -------------------------------------------------
    // Renderer
    // -------------------------------------------------
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    const initialWidth = window.innerWidth || 640;
    const initialHeight = window.innerHeight || 480;
    renderer.setSize(initialWidth, initialHeight);
    renderer.setClearColor(0x000000, 1);

    // -------------------------------------------------
    // Scene
    // -------------------------------------------------
    const scene = new THREE.Scene();
    // 背景は黒（地面・空・フォグは使わない）
    scene.background = new THREE.Color(0x000000);

    // -------------------------------------------------
    // Camera & Controls
    // -------------------------------------------------
    const camera = new THREE.PerspectiveCamera(66, initialWidth / initialHeight, 0.01, 1000);
    camera.position.set(3.4, 3.1, 6.2);
    camera.lookAt(0, 1, 0);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1.0, 0);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.update();

    // -------------------------------------------------
    // Lighting（VRM が真っ黒にならない最低限の照明）
    // -------------------------------------------------
    const hemi = new THREE.HemisphereLight(0x223355, 0x000000, 0.7);
    scene.add(hemi);
    const sun = new THREE.DirectionalLight(0xffffff, 0.9);
    sun.position.set(5, 10, 2);
    scene.add(sun);
    const ambient = new THREE.AmbientLight(0xffffff, 0.15);
    scene.add(ambient);

    // Fluid/Dust glow lights — subtle colored light that reacts with the avatar
    const fluidGlowColors = {
      cool: new THREE.Color(0x1a9dff),
      warm: new THREE.Color(0xff31e1)
    };
    const fluidLight = new THREE.PointLight(fluidGlowColors.cool.clone(), 1.2, 24, 2);
    fluidLight.position.set(0, 1.8, 4.8);
    scene.add(fluidLight);

    const dustLights = [];
    const dustLightCount = 3;
    const dustLightBaseColor = new THREE.Color(0xbdd7ff);
    for (let i = 0; i < dustLightCount; i++) {
      const dustLight = new THREE.PointLight(dustLightBaseColor.clone(), 0.35, 10, 2);
      scene.add(dustLight);
      dustLights.push(dustLight);
    }
    const fluidLightRadius = 3.6;
    const fluidLightHeight = 1.4;
    const dustTempVector = new THREE.Vector3();

    // -------------------------------------------------
    // Fluid-like Background（黒空間に浮かぶ流体模様）
    // 1) カメラを中心にした巨大な内向き球
    // 2) 時間変化するシェーダーで“ぬるぬる”模様を生成
    // -------------------------------------------------
    const fluidVS = /* glsl */`
      varying vec3 vWorldPos;
      void main(){
        vec4 wp = modelMatrix * vec4(position, 1.0);
        vWorldPos = wp.xyz;
        gl_Position = projectionMatrix * viewMatrix * wp;
      }
    `;

    const fluidFS = /* glsl */`
      precision highp float;
      varying vec3 vWorldPos;
      uniform vec3  uCameraPos;
      uniform float uTime;
      uniform float uScale;
      uniform float uSpeed;

      // 安価な多重干渉場（sin 波を重ねて流体風に見せる）
      float field(vec3 p, float t){
        // 高さ依存でわずかに旋回させる（渦っぽさ）
        float c = cos(0.25*t + p.y*0.75);
        float s = sin(0.25*t + p.y*0.75);
        mat2 R = mat2(c,-s,s,c);
        p.xz = R * p.xz;

        float v = 0.0;
        v += sin(p.x*1.00 + t) * sin(p.y*1.20 - t*1.10) * sin(p.z*0.90 + t*0.70);
        v += 0.5  * sin(p.x*2.30 - t*1.70) * sin(p.y*1.70 + t*1.50);
        v += 0.25 * sin(p.x*4.10 + t*2.20 + sin(p.z*0.50)) * sin(p.y*3.10 - t*2.00);
        return v;
      }

      void main(){
        // 視点中心から外向きの方向ベクトル
        vec3 dir = normalize(vWorldPos - uCameraPos);

        // “落下錯覚”：模様が上へ流れる（= 自分が下へ落ちているように感じる）
        float t = uTime * uSpeed;
        vec3 p = dir * uScale + vec3(0.0, t*0.6, 0.0);

        // 多層の干渉パターン
        float v1 = field(p, t);
        float v2 = field(p*0.5 + 3.1, t*1.3);
        float v  = 0.5 + 0.5*(0.7*v1 + 0.3*v2);

        // エッジ強調で“ぬるっ”とした境界を発光気味に
        float e = clamp(length(vec2(dFdx(v), dFdy(v))) * 8.0, 0.0, 1.0);

        // カラーパレット（黒→シアン→マゼンタ寄りのグロー）
        vec3 base = vec3(0.0);
        vec3 c1 = vec3(0.0, 0.7, 1.3);
        vec3 c2 = vec3(1.1, 0.2, 0.9);

        vec3 col = mix(base, c1, smoothstep(0.25, 0.85, v));
        col = mix(col, c2, smoothstep(0.55, 0.98, v));
        col += e * 0.25;

        // ほんのりビネット（極域の破綻隠し）
        float vig = pow(1.0 - abs(dir.y), 0.35);
        col *= mix(0.6, 1.0, vig);

        gl_FragColor = vec4(col, 1.0);
      }
    `;

    const fluidUniforms = {
      uCameraPos: { value: new THREE.Vector3() },
      uTime:      { value: 0 },
      uScale:     { value: 3.0 },  // 模様のスケール（大きさ）
      uSpeed:     { value: 1.0 }   // 流れる速さ（落下感）
    };

    const fluidMat = new THREE.ShaderMaterial({
      uniforms: fluidUniforms,
      vertexShader: fluidVS,
      fragmentShader: fluidFS,
      side: THREE.BackSide,
      depthWrite: false,
      depthTest: false,
      transparent: false
    });
    // WebGL1 互換用に派生計算を許可（dFdx/dFdy）
    fluidMat.extensions = { derivatives: true };

    // カメラを中心にした巨大な内向き球
    const fluidSphere = new THREE.Mesh(
      new THREE.SphereGeometry(200, 64, 64),
      fluidMat
    );
    fluidSphere.renderOrder = -9999; // 先に描く
    scene.add(fluidSphere);

    // -------------------------------------------------
    // Fluid palette sampler（背景シェーダーの色を再利用）
    // -------------------------------------------------
    const fluidPalette1 = new THREE.Color().setRGB(0.0, 0.7, 1.3);
    const fluidPalette2 = new THREE.Color().setRGB(1.1, 0.2, 0.9);
    const fluidSampleTemp = new THREE.Vector3();
    const fluidSampleTemp2 = new THREE.Vector3();

    const smoothstep = (edge0, edge1, x) => {
      const tVal = THREE.MathUtils.clamp((x - edge0) / (edge1 - edge0), 0, 1);
      return tVal * tVal * (3 - 2 * tVal);
    };

    const fluidFieldEval = (p, t) => {
      const rot = 0.25 * t + p.y * 0.75;
      const c = Math.cos(rot);
      const s = Math.sin(rot);
      const x = c * p.x - s * p.z;
      const z = s * p.x + c * p.z;

      let v = 0.0;
      v += Math.sin(x * 1.0 + t) * Math.sin(p.y * 1.2 - t * 1.1) * Math.sin(z * 0.9 + t * 0.7);
      v += 0.5 * Math.sin(x * 2.3 - t * 1.7) * Math.sin(p.y * 1.7 + t * 1.5);
      v += 0.25 * Math.sin(x * 4.1 + t * 2.2 + Math.sin(z * 0.5)) * Math.sin(p.y * 3.1 - t * 2.0);
      return v;
    };

    const sampleFluidColor = (dir, outColor, time) => {
      const scale = fluidUniforms.uScale.value;
      const speed = fluidUniforms.uSpeed.value;
      const scaledTime = time * speed;

      fluidSampleTemp.copy(dir).multiplyScalar(scale);
      fluidSampleTemp.y += scaledTime * 0.6;

      const v1 = fluidFieldEval(fluidSampleTemp, scaledTime);
      fluidSampleTemp2.copy(fluidSampleTemp).multiplyScalar(0.5).addScalar(3.1);
      const v2 = fluidFieldEval(fluidSampleTemp2, scaledTime * 1.3);

      const v = 0.5 + 0.5 * (0.7 * v1 + 0.3 * v2);
      const s1 = smoothstep(0.25, 0.85, v);
      const s2 = smoothstep(0.55, 0.98, v);

      outColor.copy(fluidPalette1).multiplyScalar(s1);
      outColor.lerp(fluidPalette2, s2);

      const vig = Math.pow(1.0 - Math.abs(dir.y), 0.35);
      const vigMix = THREE.MathUtils.lerp(0.6, 1.0, vig);
      outColor.multiplyScalar(vigMix);

      return outColor;
    };

    // -------------------------------------------------
    // Dust Particles（ゆっくり漂う微粒子）
    // -------------------------------------------------
    const createDustTexture = () => {
      const size = 128;
      const dustCanvas = document.createElement('canvas');
      dustCanvas.width = dustCanvas.height = size;
      const ctx = dustCanvas.getContext('2d');
      const gradient = ctx.createRadialGradient(size * 0.5, size * 0.5, 0, size * 0.5, size * 0.5, size * 0.5);
      gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
      gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, size, size);
      const texture = new THREE.CanvasTexture(dustCanvas);
      texture.generateMipmaps = false;
      texture.needsUpdate = true;
      return texture;
    };

    const dustCount = 80;
    const dustHeight = 10;
    const dustRadius = 6;
    const dustPositions = new Float32Array(dustCount * 3);
    const dustSpeeds = new Float32Array(dustCount);
    const dustAnchorIndices = [0, 23, 57];

    for (let i = 0; i < dustCount; i++) {
      const idx = i * 3;
      dustPositions[idx] = (Math.random() - 0.5) * dustRadius * 2;
      dustPositions[idx + 1] = (Math.random() - 0.5) * dustHeight;
      dustPositions[idx + 2] = (Math.random() - 0.5) * dustRadius * 2;
      dustSpeeds[i] = 0.4 + Math.random() * 0.35;
    }

    const dustGeometry = new THREE.BufferGeometry();
    dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));

    const dustMaterial = new THREE.PointsMaterial({
      map: createDustTexture(),
      size: 0.16,
      sizeAttenuation: true,
      transparent: true,
      opacity: 0.85,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      color: new THREE.Color(0x9fd5ff)
    });

    const dustPoints = new THREE.Points(dustGeometry, dustMaterial);
    dustPoints.frustumCulled = false;

    const dustContainer = new THREE.Group();
    dustContainer.add(dustPoints);
    dustContainer.renderOrder = -9998;
    scene.add(dustContainer);

    // -------------------------------------------------
    // GVRM（ Falling アニメで“落下中”のアバター ）
    // -------------------------------------------------
    // gvrmファイルは、Scaniverseでplyファイルを作って、https://github.com/naruya/gaussian-vrm でgvrmに変換してください
    const gvrm = await GVRM.load('./avatar.gvrm', scene, camera, renderer);
    const character = gvrm.character.currentVrm.scene;
    character.position.set(0, 1, 0);

    await gvrm.changeFBX('./Falling.fbx');
    gvrm.character.action.play();

    // Fluid color projection lights — sample background palette onto the avatar
    const fluidProjectionOriginOffset = new THREE.Vector3(0, 1.1, 0);
    const fluidProjectionDistance = 5.6;
    const fluidProjectionDirections = [
      new THREE.Vector3(0, 0, -1),
      new THREE.Vector3(0.25, 0.05, 1),
      new THREE.Vector3(-1, 0.1, 0.2),
      new THREE.Vector3(1, -0.05, 0.15),
      new THREE.Vector3(0, 1, 0.1)
    ];

    const getColorLuminance = (color) => {
      // Using Rec. 709 luminance weights to approximate perceived brightness
      return color.r * 0.2126 + color.g * 0.7152 + color.b * 0.0722;
    };

    const fluidProjectionLights = fluidProjectionDirections.map((dir) => {
      const normalized = dir.clone().normalize();
      const light = new THREE.DirectionalLight(new THREE.Color(), 0.4);
      light.castShadow = false;
      const target = new THREE.Object3D();
      scene.add(target);
      light.target = target;
      scene.add(light);
      return {
        dir: normalized,
        light,
        target,
        color: new THREE.Color()
      };
    });
    const fluidProjectionOrigin = new THREE.Vector3();
    const fluidProjectionTempPos = new THREE.Vector3();

    // -------------------------------------------------
    // Resize
    // -------------------------------------------------
    const handleResize = () => {
      const w = window.innerWidth || 640;
      const h = window.innerHeight || 480;
      renderer.setSize(w, h);
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
    };
    window.addEventListener('resize', handleResize);
    handleResize();

    // -------------------------------------------------
    // Loop
    // -------------------------------------------------
    const clock = new THREE.Clock();

    renderer.setAnimationLoop(() => {
      const dt = clock.getDelta();
      const t = clock.elapsedTime;

      // Fluid 背景をカメラ中心に固定（無限空間の錯覚）
      fluidSphere.position.copy(camera.position);
      fluidUniforms.uCameraPos.value.copy(camera.position);
      fluidUniforms.uTime.value = t;

      // 背景の色をサンプリングしてアバターへ投影
      fluidProjectionOrigin.copy(character.position).add(fluidProjectionOriginOffset);
      const envSampleTime = fluidUniforms.uTime.value;
      for (const projection of fluidProjectionLights) {
        sampleFluidColor(projection.dir, projection.color, envSampleTime);
        const luminance = THREE.MathUtils.clamp(getColorLuminance(projection.color), 0, 1.4);
        projection.light.color.copy(projection.color);
        projection.light.intensity = 0.25 + luminance * 1.1;
        projection.target.position.copy(fluidProjectionOrigin);
        fluidProjectionTempPos.copy(fluidProjectionOrigin).addScaledVector(projection.dir, -fluidProjectionDistance);
        projection.light.position.copy(fluidProjectionTempPos);
      }

      // Dust をカメラ基準で漂わせる
      const positionAttr = dustGeometry.getAttribute('position');
      const posArray = positionAttr.array;
      for (let i = 0; i < dustCount; i++) {
        const base = i * 3;
        const yIndex = base + 1;
        posArray[yIndex] += dustSpeeds[i] * dt;
        if (posArray[yIndex] > dustHeight * 0.5) {
          posArray[yIndex] = -dustHeight * 0.5;
          posArray[base] = (Math.random() - 0.5) * dustRadius * 2;
          posArray[base + 2] = (Math.random() - 0.5) * dustRadius * 2;
        }
      }
      positionAttr.needsUpdate = true;
      dustContainer.position.copy(camera.position);

      // Fluid light swirls around the avatar and carries the shader palette onto it
      const fluidPhase = t * 0.35;
      fluidLight.position.set(
        character.position.x + Math.cos(fluidPhase) * fluidLightRadius,
        character.position.y + fluidLightHeight + Math.sin(t * 0.6) * 0.8,
        character.position.z + Math.sin(fluidPhase) * fluidLightRadius
      );
      const fluidMix = 0.5 + 0.5 * Math.sin(t * 0.45) * Math.sin(t * 0.3 + 1.2);
      fluidLight.color.copy(fluidGlowColors.cool).lerp(fluidGlowColors.warm, fluidMix);
      fluidLight.intensity = 0.9 + 0.4 * Math.sin(t * 0.5 + Math.cos(t * 0.2));

      // Dust lights tether to representative particles and add flickering fills
      for (let i = 0; i < dustLights.length; i++) {
        const anchorIndex = dustAnchorIndices[i % dustAnchorIndices.length] * 3;
        dustTempVector.set(
          posArray[anchorIndex],
          posArray[anchorIndex + 1],
          posArray[anchorIndex + 2]
        );
        dustLights[i].position.copy(dustContainer.position).add(dustTempVector);
        const dustPulse = 0.5 + 0.5 * Math.sin(t * 1.2 + i * 1.4);
        dustLights[i].intensity = 0.25 + dustPulse * 0.35;
        const dustHueMix = 0.25 + 0.25 * Math.sin(t * 0.9 + i * 0.6);
        dustLights[i].color.copy(dustLightBaseColor).lerp(fluidGlowColors.warm, dustHueMix);
      }

      gvrm.update();
      controls.update();
      renderer.render(scene, camera);
    });
  </script>
</body>
